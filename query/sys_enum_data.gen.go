// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"ResourceManage/model"
)

func newSysEnumDatum(db *gorm.DB, opts ...gen.DOOption) sysEnumDatum {
	_sysEnumDatum := sysEnumDatum{}

	_sysEnumDatum.sysEnumDatumDo.UseDB(db, opts...)
	_sysEnumDatum.sysEnumDatumDo.UseModel(&model.SysEnumDatum{})

	tableName := _sysEnumDatum.sysEnumDatumDo.TableName()
	_sysEnumDatum.ALL = field.NewAsterisk(tableName)
	_sysEnumDatum.ID = field.NewInt64(tableName, "id")
	_sysEnumDatum.DictSort = field.NewInt64(tableName, "dict_sort")
	_sysEnumDatum.DictLabel = field.NewString(tableName, "dict_label")
	_sysEnumDatum.DictValue = field.NewString(tableName, "dict_value")
	_sysEnumDatum.DictName = field.NewString(tableName, "dict_name")
	_sysEnumDatum.CSSClass = field.NewString(tableName, "css_class")
	_sysEnumDatum.ListClass = field.NewString(tableName, "list_class")
	_sysEnumDatum.IsDefault = field.NewString(tableName, "is_default")
	_sysEnumDatum.Status = field.NewInt64(tableName, "status")
	_sysEnumDatum.Default = field.NewString(tableName, "default")
	_sysEnumDatum.CreateBy = field.NewString(tableName, "create_by")
	_sysEnumDatum.UpdateBy = field.NewString(tableName, "update_by")
	_sysEnumDatum.Remark = field.NewString(tableName, "remark")
	_sysEnumDatum.CreatedTime = field.NewTime(tableName, "created_time")
	_sysEnumDatum.UpdatedTime = field.NewTime(tableName, "updated_time")
	_sysEnumDatum.Deleted = field.NewInt64(tableName, "deleted")

	_sysEnumDatum.fillFieldMap()

	return _sysEnumDatum
}

type sysEnumDatum struct {
	sysEnumDatumDo

	ALL         field.Asterisk
	ID          field.Int64
	DictSort    field.Int64
	DictLabel   field.String
	DictValue   field.String
	DictName    field.String
	CSSClass    field.String
	ListClass   field.String
	IsDefault   field.String
	Status      field.Int64 // 1-正常；2-禁用
	Default     field.String
	CreateBy    field.String
	UpdateBy    field.String
	Remark      field.String
	CreatedTime field.Time
	UpdatedTime field.Time
	Deleted     field.Int64 // 1-删除；2-未删除

	fieldMap map[string]field.Expr
}

func (s sysEnumDatum) Table(newTableName string) *sysEnumDatum {
	s.sysEnumDatumDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s sysEnumDatum) As(alias string) *sysEnumDatum {
	s.sysEnumDatumDo.DO = *(s.sysEnumDatumDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *sysEnumDatum) updateTableName(table string) *sysEnumDatum {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewInt64(table, "id")
	s.DictSort = field.NewInt64(table, "dict_sort")
	s.DictLabel = field.NewString(table, "dict_label")
	s.DictValue = field.NewString(table, "dict_value")
	s.DictName = field.NewString(table, "dict_name")
	s.CSSClass = field.NewString(table, "css_class")
	s.ListClass = field.NewString(table, "list_class")
	s.IsDefault = field.NewString(table, "is_default")
	s.Status = field.NewInt64(table, "status")
	s.Default = field.NewString(table, "default")
	s.CreateBy = field.NewString(table, "create_by")
	s.UpdateBy = field.NewString(table, "update_by")
	s.Remark = field.NewString(table, "remark")
	s.CreatedTime = field.NewTime(table, "created_time")
	s.UpdatedTime = field.NewTime(table, "updated_time")
	s.Deleted = field.NewInt64(table, "deleted")

	s.fillFieldMap()

	return s
}

func (s *sysEnumDatum) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *sysEnumDatum) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 16)
	s.fieldMap["id"] = s.ID
	s.fieldMap["dict_sort"] = s.DictSort
	s.fieldMap["dict_label"] = s.DictLabel
	s.fieldMap["dict_value"] = s.DictValue
	s.fieldMap["dict_name"] = s.DictName
	s.fieldMap["css_class"] = s.CSSClass
	s.fieldMap["list_class"] = s.ListClass
	s.fieldMap["is_default"] = s.IsDefault
	s.fieldMap["status"] = s.Status
	s.fieldMap["default"] = s.Default
	s.fieldMap["create_by"] = s.CreateBy
	s.fieldMap["update_by"] = s.UpdateBy
	s.fieldMap["remark"] = s.Remark
	s.fieldMap["created_time"] = s.CreatedTime
	s.fieldMap["updated_time"] = s.UpdatedTime
	s.fieldMap["deleted"] = s.Deleted
}

func (s sysEnumDatum) clone(db *gorm.DB) sysEnumDatum {
	s.sysEnumDatumDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s sysEnumDatum) replaceDB(db *gorm.DB) sysEnumDatum {
	s.sysEnumDatumDo.ReplaceDB(db)
	return s
}

type sysEnumDatumDo struct{ gen.DO }

type ISysEnumDatumDo interface {
	gen.SubQuery
	Debug() ISysEnumDatumDo
	WithContext(ctx context.Context) ISysEnumDatumDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ISysEnumDatumDo
	WriteDB() ISysEnumDatumDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ISysEnumDatumDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISysEnumDatumDo
	Not(conds ...gen.Condition) ISysEnumDatumDo
	Or(conds ...gen.Condition) ISysEnumDatumDo
	Select(conds ...field.Expr) ISysEnumDatumDo
	Where(conds ...gen.Condition) ISysEnumDatumDo
	Order(conds ...field.Expr) ISysEnumDatumDo
	Distinct(cols ...field.Expr) ISysEnumDatumDo
	Omit(cols ...field.Expr) ISysEnumDatumDo
	Join(table schema.Tabler, on ...field.Expr) ISysEnumDatumDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISysEnumDatumDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISysEnumDatumDo
	Group(cols ...field.Expr) ISysEnumDatumDo
	Having(conds ...gen.Condition) ISysEnumDatumDo
	Limit(limit int) ISysEnumDatumDo
	Offset(offset int) ISysEnumDatumDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISysEnumDatumDo
	Unscoped() ISysEnumDatumDo
	Create(values ...*model.SysEnumDatum) error
	CreateInBatches(values []*model.SysEnumDatum, batchSize int) error
	Save(values ...*model.SysEnumDatum) error
	First() (*model.SysEnumDatum, error)
	Take() (*model.SysEnumDatum, error)
	Last() (*model.SysEnumDatum, error)
	Find() ([]*model.SysEnumDatum, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SysEnumDatum, err error)
	FindInBatches(result *[]*model.SysEnumDatum, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.SysEnumDatum) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISysEnumDatumDo
	Assign(attrs ...field.AssignExpr) ISysEnumDatumDo
	Joins(fields ...field.RelationField) ISysEnumDatumDo
	Preload(fields ...field.RelationField) ISysEnumDatumDo
	FirstOrInit() (*model.SysEnumDatum, error)
	FirstOrCreate() (*model.SysEnumDatum, error)
	FindByPage(offset int, limit int) (result []*model.SysEnumDatum, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISysEnumDatumDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s sysEnumDatumDo) Debug() ISysEnumDatumDo {
	return s.withDO(s.DO.Debug())
}

func (s sysEnumDatumDo) WithContext(ctx context.Context) ISysEnumDatumDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s sysEnumDatumDo) ReadDB() ISysEnumDatumDo {
	return s.Clauses(dbresolver.Read)
}

func (s sysEnumDatumDo) WriteDB() ISysEnumDatumDo {
	return s.Clauses(dbresolver.Write)
}

func (s sysEnumDatumDo) Session(config *gorm.Session) ISysEnumDatumDo {
	return s.withDO(s.DO.Session(config))
}

func (s sysEnumDatumDo) Clauses(conds ...clause.Expression) ISysEnumDatumDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s sysEnumDatumDo) Returning(value interface{}, columns ...string) ISysEnumDatumDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s sysEnumDatumDo) Not(conds ...gen.Condition) ISysEnumDatumDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s sysEnumDatumDo) Or(conds ...gen.Condition) ISysEnumDatumDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s sysEnumDatumDo) Select(conds ...field.Expr) ISysEnumDatumDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s sysEnumDatumDo) Where(conds ...gen.Condition) ISysEnumDatumDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s sysEnumDatumDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) ISysEnumDatumDo {
	return s.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (s sysEnumDatumDo) Order(conds ...field.Expr) ISysEnumDatumDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s sysEnumDatumDo) Distinct(cols ...field.Expr) ISysEnumDatumDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s sysEnumDatumDo) Omit(cols ...field.Expr) ISysEnumDatumDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s sysEnumDatumDo) Join(table schema.Tabler, on ...field.Expr) ISysEnumDatumDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s sysEnumDatumDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISysEnumDatumDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s sysEnumDatumDo) RightJoin(table schema.Tabler, on ...field.Expr) ISysEnumDatumDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s sysEnumDatumDo) Group(cols ...field.Expr) ISysEnumDatumDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s sysEnumDatumDo) Having(conds ...gen.Condition) ISysEnumDatumDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s sysEnumDatumDo) Limit(limit int) ISysEnumDatumDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s sysEnumDatumDo) Offset(offset int) ISysEnumDatumDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s sysEnumDatumDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISysEnumDatumDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s sysEnumDatumDo) Unscoped() ISysEnumDatumDo {
	return s.withDO(s.DO.Unscoped())
}

func (s sysEnumDatumDo) Create(values ...*model.SysEnumDatum) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s sysEnumDatumDo) CreateInBatches(values []*model.SysEnumDatum, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s sysEnumDatumDo) Save(values ...*model.SysEnumDatum) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s sysEnumDatumDo) First() (*model.SysEnumDatum, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysEnumDatum), nil
	}
}

func (s sysEnumDatumDo) Take() (*model.SysEnumDatum, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysEnumDatum), nil
	}
}

func (s sysEnumDatumDo) Last() (*model.SysEnumDatum, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysEnumDatum), nil
	}
}

func (s sysEnumDatumDo) Find() ([]*model.SysEnumDatum, error) {
	result, err := s.DO.Find()
	return result.([]*model.SysEnumDatum), err
}

func (s sysEnumDatumDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SysEnumDatum, err error) {
	buf := make([]*model.SysEnumDatum, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s sysEnumDatumDo) FindInBatches(result *[]*model.SysEnumDatum, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s sysEnumDatumDo) Attrs(attrs ...field.AssignExpr) ISysEnumDatumDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s sysEnumDatumDo) Assign(attrs ...field.AssignExpr) ISysEnumDatumDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s sysEnumDatumDo) Joins(fields ...field.RelationField) ISysEnumDatumDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s sysEnumDatumDo) Preload(fields ...field.RelationField) ISysEnumDatumDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s sysEnumDatumDo) FirstOrInit() (*model.SysEnumDatum, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysEnumDatum), nil
	}
}

func (s sysEnumDatumDo) FirstOrCreate() (*model.SysEnumDatum, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysEnumDatum), nil
	}
}

func (s sysEnumDatumDo) FindByPage(offset int, limit int) (result []*model.SysEnumDatum, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s sysEnumDatumDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s sysEnumDatumDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s sysEnumDatumDo) Delete(models ...*model.SysEnumDatum) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *sysEnumDatumDo) withDO(do gen.Dao) *sysEnumDatumDo {
	s.DO = *do.(*gen.DO)
	return s
}

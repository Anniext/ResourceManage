// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"ResourceManage/model"
)

func newSysBackendUser(db *gorm.DB, opts ...gen.DOOption) sysBackendUser {
	_sysBackendUser := sysBackendUser{}

	_sysBackendUser.sysBackendUserDo.UseDB(db, opts...)
	_sysBackendUser.sysBackendUserDo.UseModel(&model.SysBackendUser{})

	tableName := _sysBackendUser.sysBackendUserDo.TableName()
	_sysBackendUser.ALL = field.NewAsterisk(tableName)
	_sysBackendUser.ID = field.NewInt64(tableName, "id")
	_sysBackendUser.RealName = field.NewString(tableName, "real_name")
	_sysBackendUser.UserName = field.NewString(tableName, "user_name")
	_sysBackendUser.UserPwd = field.NewString(tableName, "user_pwd")
	_sysBackendUser.IsSuper = field.NewInt64(tableName, "is_super")
	_sysBackendUser.Status = field.NewInt64(tableName, "status")
	_sysBackendUser.Mobile = field.NewString(tableName, "mobile")
	_sysBackendUser.Email = field.NewString(tableName, "email")
	_sysBackendUser.Avatar = field.NewString(tableName, "avatar")
	_sysBackendUser.UserType = field.NewInt64(tableName, "user_type")
	_sysBackendUser.OperatorID = field.NewInt64(tableName, "operator_id")
	_sysBackendUser.ParentID = field.NewInt64(tableName, "parent_id")
	_sysBackendUser.ParentRoute = field.NewString(tableName, "parent_route")
	_sysBackendUser.Percentage = field.NewString(tableName, "percentage")
	_sysBackendUser.Quota = field.NewString(tableName, "quota")
	_sysBackendUser.KdxfLoginName = field.NewString(tableName, "kdxf_login_name")
	_sysBackendUser.Expires = field.NewInt64(tableName, "expires")
	_sysBackendUser.Level = field.NewInt64(tableName, "level")

	_sysBackendUser.fillFieldMap()

	return _sysBackendUser
}

type sysBackendUser struct {
	sysBackendUserDo

	ALL        field.Asterisk
	ID         field.Int64
	RealName   field.String // 姓名
	UserName   field.String // 账号名
	UserPwd    field.String // 账号密码
	IsSuper    field.Int64  // 是否为超级管理员
	Status     field.Int64  // 状态
	Mobile     field.String // 手机号
	Email      field.String // 邮箱
	Avatar     field.String
	UserType   field.Int64 // 1-管理员
	OperatorID field.Int64
	/*
		上级id

	*/
	ParentID      field.Int64
	ParentRoute   field.String // 所有上级路径
	Percentage    field.String
	Quota         field.String
	KdxfLoginName field.String // 科大讯飞点对点登陆账号名
	/*
		账号到期时间(day)
		空为永久有效
	*/
	Expires field.Int64
	/*
		账号权限等级
		0最高
	*/
	Level field.Int64

	fieldMap map[string]field.Expr
}

func (s sysBackendUser) Table(newTableName string) *sysBackendUser {
	s.sysBackendUserDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s sysBackendUser) As(alias string) *sysBackendUser {
	s.sysBackendUserDo.DO = *(s.sysBackendUserDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *sysBackendUser) updateTableName(table string) *sysBackendUser {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewInt64(table, "id")
	s.RealName = field.NewString(table, "real_name")
	s.UserName = field.NewString(table, "user_name")
	s.UserPwd = field.NewString(table, "user_pwd")
	s.IsSuper = field.NewInt64(table, "is_super")
	s.Status = field.NewInt64(table, "status")
	s.Mobile = field.NewString(table, "mobile")
	s.Email = field.NewString(table, "email")
	s.Avatar = field.NewString(table, "avatar")
	s.UserType = field.NewInt64(table, "user_type")
	s.OperatorID = field.NewInt64(table, "operator_id")
	s.ParentID = field.NewInt64(table, "parent_id")
	s.ParentRoute = field.NewString(table, "parent_route")
	s.Percentage = field.NewString(table, "percentage")
	s.Quota = field.NewString(table, "quota")
	s.KdxfLoginName = field.NewString(table, "kdxf_login_name")
	s.Expires = field.NewInt64(table, "expires")
	s.Level = field.NewInt64(table, "level")

	s.fillFieldMap()

	return s
}

func (s *sysBackendUser) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *sysBackendUser) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 18)
	s.fieldMap["id"] = s.ID
	s.fieldMap["real_name"] = s.RealName
	s.fieldMap["user_name"] = s.UserName
	s.fieldMap["user_pwd"] = s.UserPwd
	s.fieldMap["is_super"] = s.IsSuper
	s.fieldMap["status"] = s.Status
	s.fieldMap["mobile"] = s.Mobile
	s.fieldMap["email"] = s.Email
	s.fieldMap["avatar"] = s.Avatar
	s.fieldMap["user_type"] = s.UserType
	s.fieldMap["operator_id"] = s.OperatorID
	s.fieldMap["parent_id"] = s.ParentID
	s.fieldMap["parent_route"] = s.ParentRoute
	s.fieldMap["percentage"] = s.Percentage
	s.fieldMap["quota"] = s.Quota
	s.fieldMap["kdxf_login_name"] = s.KdxfLoginName
	s.fieldMap["expires"] = s.Expires
	s.fieldMap["level"] = s.Level
}

func (s sysBackendUser) clone(db *gorm.DB) sysBackendUser {
	s.sysBackendUserDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s sysBackendUser) replaceDB(db *gorm.DB) sysBackendUser {
	s.sysBackendUserDo.ReplaceDB(db)
	return s
}

type sysBackendUserDo struct{ gen.DO }

type ISysBackendUserDo interface {
	gen.SubQuery
	Debug() ISysBackendUserDo
	WithContext(ctx context.Context) ISysBackendUserDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ISysBackendUserDo
	WriteDB() ISysBackendUserDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ISysBackendUserDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISysBackendUserDo
	Not(conds ...gen.Condition) ISysBackendUserDo
	Or(conds ...gen.Condition) ISysBackendUserDo
	Select(conds ...field.Expr) ISysBackendUserDo
	Where(conds ...gen.Condition) ISysBackendUserDo
	Order(conds ...field.Expr) ISysBackendUserDo
	Distinct(cols ...field.Expr) ISysBackendUserDo
	Omit(cols ...field.Expr) ISysBackendUserDo
	Join(table schema.Tabler, on ...field.Expr) ISysBackendUserDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISysBackendUserDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISysBackendUserDo
	Group(cols ...field.Expr) ISysBackendUserDo
	Having(conds ...gen.Condition) ISysBackendUserDo
	Limit(limit int) ISysBackendUserDo
	Offset(offset int) ISysBackendUserDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISysBackendUserDo
	Unscoped() ISysBackendUserDo
	Create(values ...*model.SysBackendUser) error
	CreateInBatches(values []*model.SysBackendUser, batchSize int) error
	Save(values ...*model.SysBackendUser) error
	First() (*model.SysBackendUser, error)
	Take() (*model.SysBackendUser, error)
	Last() (*model.SysBackendUser, error)
	Find() ([]*model.SysBackendUser, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SysBackendUser, err error)
	FindInBatches(result *[]*model.SysBackendUser, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.SysBackendUser) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISysBackendUserDo
	Assign(attrs ...field.AssignExpr) ISysBackendUserDo
	Joins(fields ...field.RelationField) ISysBackendUserDo
	Preload(fields ...field.RelationField) ISysBackendUserDo
	FirstOrInit() (*model.SysBackendUser, error)
	FirstOrCreate() (*model.SysBackendUser, error)
	FindByPage(offset int, limit int) (result []*model.SysBackendUser, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISysBackendUserDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s sysBackendUserDo) Debug() ISysBackendUserDo {
	return s.withDO(s.DO.Debug())
}

func (s sysBackendUserDo) WithContext(ctx context.Context) ISysBackendUserDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s sysBackendUserDo) ReadDB() ISysBackendUserDo {
	return s.Clauses(dbresolver.Read)
}

func (s sysBackendUserDo) WriteDB() ISysBackendUserDo {
	return s.Clauses(dbresolver.Write)
}

func (s sysBackendUserDo) Session(config *gorm.Session) ISysBackendUserDo {
	return s.withDO(s.DO.Session(config))
}

func (s sysBackendUserDo) Clauses(conds ...clause.Expression) ISysBackendUserDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s sysBackendUserDo) Returning(value interface{}, columns ...string) ISysBackendUserDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s sysBackendUserDo) Not(conds ...gen.Condition) ISysBackendUserDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s sysBackendUserDo) Or(conds ...gen.Condition) ISysBackendUserDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s sysBackendUserDo) Select(conds ...field.Expr) ISysBackendUserDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s sysBackendUserDo) Where(conds ...gen.Condition) ISysBackendUserDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s sysBackendUserDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) ISysBackendUserDo {
	return s.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (s sysBackendUserDo) Order(conds ...field.Expr) ISysBackendUserDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s sysBackendUserDo) Distinct(cols ...field.Expr) ISysBackendUserDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s sysBackendUserDo) Omit(cols ...field.Expr) ISysBackendUserDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s sysBackendUserDo) Join(table schema.Tabler, on ...field.Expr) ISysBackendUserDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s sysBackendUserDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISysBackendUserDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s sysBackendUserDo) RightJoin(table schema.Tabler, on ...field.Expr) ISysBackendUserDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s sysBackendUserDo) Group(cols ...field.Expr) ISysBackendUserDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s sysBackendUserDo) Having(conds ...gen.Condition) ISysBackendUserDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s sysBackendUserDo) Limit(limit int) ISysBackendUserDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s sysBackendUserDo) Offset(offset int) ISysBackendUserDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s sysBackendUserDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISysBackendUserDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s sysBackendUserDo) Unscoped() ISysBackendUserDo {
	return s.withDO(s.DO.Unscoped())
}

func (s sysBackendUserDo) Create(values ...*model.SysBackendUser) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s sysBackendUserDo) CreateInBatches(values []*model.SysBackendUser, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s sysBackendUserDo) Save(values ...*model.SysBackendUser) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s sysBackendUserDo) First() (*model.SysBackendUser, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysBackendUser), nil
	}
}

func (s sysBackendUserDo) Take() (*model.SysBackendUser, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysBackendUser), nil
	}
}

func (s sysBackendUserDo) Last() (*model.SysBackendUser, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysBackendUser), nil
	}
}

func (s sysBackendUserDo) Find() ([]*model.SysBackendUser, error) {
	result, err := s.DO.Find()
	return result.([]*model.SysBackendUser), err
}

func (s sysBackendUserDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SysBackendUser, err error) {
	buf := make([]*model.SysBackendUser, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s sysBackendUserDo) FindInBatches(result *[]*model.SysBackendUser, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s sysBackendUserDo) Attrs(attrs ...field.AssignExpr) ISysBackendUserDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s sysBackendUserDo) Assign(attrs ...field.AssignExpr) ISysBackendUserDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s sysBackendUserDo) Joins(fields ...field.RelationField) ISysBackendUserDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s sysBackendUserDo) Preload(fields ...field.RelationField) ISysBackendUserDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s sysBackendUserDo) FirstOrInit() (*model.SysBackendUser, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysBackendUser), nil
	}
}

func (s sysBackendUserDo) FirstOrCreate() (*model.SysBackendUser, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.SysBackendUser), nil
	}
}

func (s sysBackendUserDo) FindByPage(offset int, limit int) (result []*model.SysBackendUser, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s sysBackendUserDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s sysBackendUserDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s sysBackendUserDo) Delete(models ...*model.SysBackendUser) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *sysBackendUserDo) withDO(do gen.Dao) *sysBackendUserDo {
	s.DO = *do.(*gen.DO)
	return s
}

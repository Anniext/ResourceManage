// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"ResourceManage/model"
)

func newAvtUnit(db *gorm.DB, opts ...gen.DOOption) avtUnit {
	_avtUnit := avtUnit{}

	_avtUnit.avtUnitDo.UseDB(db, opts...)
	_avtUnit.avtUnitDo.UseModel(&model.AvtUnit{})

	tableName := _avtUnit.avtUnitDo.TableName()
	_avtUnit.ALL = field.NewAsterisk(tableName)
	_avtUnit.ID = field.NewInt64(tableName, "id")
	_avtUnit.Name = field.NewString(tableName, "name")
	_avtUnit.Level = field.NewInt64(tableName, "level")
	_avtUnit.CreateTime = field.NewTime(tableName, "create_time")
	_avtUnit.UpdateTime = field.NewTime(tableName, "update_time")
	_avtUnit.ParentID = field.NewInt64(tableName, "parent_id")
	_avtUnit.Address = field.NewString(tableName, "address")
	_avtUnit.UserID = field.NewInt64(tableName, "user_id")

	_avtUnit.fillFieldMap()

	return _avtUnit
}

type avtUnit struct {
	avtUnitDo

	ALL        field.Asterisk
	ID         field.Int64  // 单位id
	Name       field.String // 单位名
	Level      field.Int64  // 单位级别
	CreateTime field.Time   // 创建时间
	UpdateTime field.Time   // 更新时间
	ParentID   field.Int64  // 上级单位id
	Address    field.String // 单位地址
	UserID     field.Int64  // 用户id

	fieldMap map[string]field.Expr
}

func (a avtUnit) Table(newTableName string) *avtUnit {
	a.avtUnitDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a avtUnit) As(alias string) *avtUnit {
	a.avtUnitDo.DO = *(a.avtUnitDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *avtUnit) updateTableName(table string) *avtUnit {
	a.ALL = field.NewAsterisk(table)
	a.ID = field.NewInt64(table, "id")
	a.Name = field.NewString(table, "name")
	a.Level = field.NewInt64(table, "level")
	a.CreateTime = field.NewTime(table, "create_time")
	a.UpdateTime = field.NewTime(table, "update_time")
	a.ParentID = field.NewInt64(table, "parent_id")
	a.Address = field.NewString(table, "address")
	a.UserID = field.NewInt64(table, "user_id")

	a.fillFieldMap()

	return a
}

func (a *avtUnit) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *avtUnit) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 8)
	a.fieldMap["id"] = a.ID
	a.fieldMap["name"] = a.Name
	a.fieldMap["level"] = a.Level
	a.fieldMap["create_time"] = a.CreateTime
	a.fieldMap["update_time"] = a.UpdateTime
	a.fieldMap["parent_id"] = a.ParentID
	a.fieldMap["address"] = a.Address
	a.fieldMap["user_id"] = a.UserID
}

func (a avtUnit) clone(db *gorm.DB) avtUnit {
	a.avtUnitDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a avtUnit) replaceDB(db *gorm.DB) avtUnit {
	a.avtUnitDo.ReplaceDB(db)
	return a
}

type avtUnitDo struct{ gen.DO }

type IAvtUnitDo interface {
	gen.SubQuery
	Debug() IAvtUnitDo
	WithContext(ctx context.Context) IAvtUnitDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IAvtUnitDo
	WriteDB() IAvtUnitDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IAvtUnitDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IAvtUnitDo
	Not(conds ...gen.Condition) IAvtUnitDo
	Or(conds ...gen.Condition) IAvtUnitDo
	Select(conds ...field.Expr) IAvtUnitDo
	Where(conds ...gen.Condition) IAvtUnitDo
	Order(conds ...field.Expr) IAvtUnitDo
	Distinct(cols ...field.Expr) IAvtUnitDo
	Omit(cols ...field.Expr) IAvtUnitDo
	Join(table schema.Tabler, on ...field.Expr) IAvtUnitDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IAvtUnitDo
	RightJoin(table schema.Tabler, on ...field.Expr) IAvtUnitDo
	Group(cols ...field.Expr) IAvtUnitDo
	Having(conds ...gen.Condition) IAvtUnitDo
	Limit(limit int) IAvtUnitDo
	Offset(offset int) IAvtUnitDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IAvtUnitDo
	Unscoped() IAvtUnitDo
	Create(values ...*model.AvtUnit) error
	CreateInBatches(values []*model.AvtUnit, batchSize int) error
	Save(values ...*model.AvtUnit) error
	First() (*model.AvtUnit, error)
	Take() (*model.AvtUnit, error)
	Last() (*model.AvtUnit, error)
	Find() ([]*model.AvtUnit, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.AvtUnit, err error)
	FindInBatches(result *[]*model.AvtUnit, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.AvtUnit) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IAvtUnitDo
	Assign(attrs ...field.AssignExpr) IAvtUnitDo
	Joins(fields ...field.RelationField) IAvtUnitDo
	Preload(fields ...field.RelationField) IAvtUnitDo
	FirstOrInit() (*model.AvtUnit, error)
	FirstOrCreate() (*model.AvtUnit, error)
	FindByPage(offset int, limit int) (result []*model.AvtUnit, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IAvtUnitDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (a avtUnitDo) Debug() IAvtUnitDo {
	return a.withDO(a.DO.Debug())
}

func (a avtUnitDo) WithContext(ctx context.Context) IAvtUnitDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a avtUnitDo) ReadDB() IAvtUnitDo {
	return a.Clauses(dbresolver.Read)
}

func (a avtUnitDo) WriteDB() IAvtUnitDo {
	return a.Clauses(dbresolver.Write)
}

func (a avtUnitDo) Session(config *gorm.Session) IAvtUnitDo {
	return a.withDO(a.DO.Session(config))
}

func (a avtUnitDo) Clauses(conds ...clause.Expression) IAvtUnitDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a avtUnitDo) Returning(value interface{}, columns ...string) IAvtUnitDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a avtUnitDo) Not(conds ...gen.Condition) IAvtUnitDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a avtUnitDo) Or(conds ...gen.Condition) IAvtUnitDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a avtUnitDo) Select(conds ...field.Expr) IAvtUnitDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a avtUnitDo) Where(conds ...gen.Condition) IAvtUnitDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a avtUnitDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IAvtUnitDo {
	return a.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (a avtUnitDo) Order(conds ...field.Expr) IAvtUnitDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a avtUnitDo) Distinct(cols ...field.Expr) IAvtUnitDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a avtUnitDo) Omit(cols ...field.Expr) IAvtUnitDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a avtUnitDo) Join(table schema.Tabler, on ...field.Expr) IAvtUnitDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a avtUnitDo) LeftJoin(table schema.Tabler, on ...field.Expr) IAvtUnitDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a avtUnitDo) RightJoin(table schema.Tabler, on ...field.Expr) IAvtUnitDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a avtUnitDo) Group(cols ...field.Expr) IAvtUnitDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a avtUnitDo) Having(conds ...gen.Condition) IAvtUnitDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a avtUnitDo) Limit(limit int) IAvtUnitDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a avtUnitDo) Offset(offset int) IAvtUnitDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a avtUnitDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IAvtUnitDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a avtUnitDo) Unscoped() IAvtUnitDo {
	return a.withDO(a.DO.Unscoped())
}

func (a avtUnitDo) Create(values ...*model.AvtUnit) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a avtUnitDo) CreateInBatches(values []*model.AvtUnit, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a avtUnitDo) Save(values ...*model.AvtUnit) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a avtUnitDo) First() (*model.AvtUnit, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.AvtUnit), nil
	}
}

func (a avtUnitDo) Take() (*model.AvtUnit, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.AvtUnit), nil
	}
}

func (a avtUnitDo) Last() (*model.AvtUnit, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.AvtUnit), nil
	}
}

func (a avtUnitDo) Find() ([]*model.AvtUnit, error) {
	result, err := a.DO.Find()
	return result.([]*model.AvtUnit), err
}

func (a avtUnitDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.AvtUnit, err error) {
	buf := make([]*model.AvtUnit, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a avtUnitDo) FindInBatches(result *[]*model.AvtUnit, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a avtUnitDo) Attrs(attrs ...field.AssignExpr) IAvtUnitDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a avtUnitDo) Assign(attrs ...field.AssignExpr) IAvtUnitDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a avtUnitDo) Joins(fields ...field.RelationField) IAvtUnitDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a avtUnitDo) Preload(fields ...field.RelationField) IAvtUnitDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a avtUnitDo) FirstOrInit() (*model.AvtUnit, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.AvtUnit), nil
	}
}

func (a avtUnitDo) FirstOrCreate() (*model.AvtUnit, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.AvtUnit), nil
	}
}

func (a avtUnitDo) FindByPage(offset int, limit int) (result []*model.AvtUnit, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a avtUnitDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a avtUnitDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a avtUnitDo) Delete(models ...*model.AvtUnit) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *avtUnitDo) withDO(do gen.Dao) *avtUnitDo {
	a.DO = *do.(*gen.DO)
	return a
}

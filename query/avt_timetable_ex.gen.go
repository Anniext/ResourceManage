// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"ResourceManage/model"
)

func newAvtTimetableEx(db *gorm.DB, opts ...gen.DOOption) avtTimetableEx {
	_avtTimetableEx := avtTimetableEx{}

	_avtTimetableEx.avtTimetableExDo.UseDB(db, opts...)
	_avtTimetableEx.avtTimetableExDo.UseModel(&model.AvtTimetableEx{})

	tableName := _avtTimetableEx.avtTimetableExDo.TableName()
	_avtTimetableEx.ALL = field.NewAsterisk(tableName)
	_avtTimetableEx.ID = field.NewInt64(tableName, "id")
	_avtTimetableEx.RoomID = field.NewInt64(tableName, "room_id")
	_avtTimetableEx.RoomIP = field.NewString(tableName, "room_ip")
	_avtTimetableEx.Card = field.NewString(tableName, "card")
	_avtTimetableEx.CadrID = field.NewString(tableName, "cadr_id")
	_avtTimetableEx.TableDate = field.NewTime(tableName, "table_date")
	_avtTimetableEx.RoomName = field.NewString(tableName, "room_name")
	_avtTimetableEx.CardType = field.NewInt64(tableName, "card_type")

	_avtTimetableEx.fillFieldMap()

	return _avtTimetableEx
}

type avtTimetableEx struct {
	avtTimetableExDo

	ALL       field.Asterisk
	ID        field.Int64
	RoomID    field.Int64
	RoomIP    field.String
	Card      field.String // 老师卡号
	CadrID    field.String // 物理卡号
	TableDate field.Time
	RoomName  field.String
	CardType  field.Int64 // 0-普通上课卡  ；1- 全部教室通用卡；2-单个教室通用卡

	fieldMap map[string]field.Expr
}

func (a avtTimetableEx) Table(newTableName string) *avtTimetableEx {
	a.avtTimetableExDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a avtTimetableEx) As(alias string) *avtTimetableEx {
	a.avtTimetableExDo.DO = *(a.avtTimetableExDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *avtTimetableEx) updateTableName(table string) *avtTimetableEx {
	a.ALL = field.NewAsterisk(table)
	a.ID = field.NewInt64(table, "id")
	a.RoomID = field.NewInt64(table, "room_id")
	a.RoomIP = field.NewString(table, "room_ip")
	a.Card = field.NewString(table, "card")
	a.CadrID = field.NewString(table, "cadr_id")
	a.TableDate = field.NewTime(table, "table_date")
	a.RoomName = field.NewString(table, "room_name")
	a.CardType = field.NewInt64(table, "card_type")

	a.fillFieldMap()

	return a
}

func (a *avtTimetableEx) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *avtTimetableEx) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 8)
	a.fieldMap["id"] = a.ID
	a.fieldMap["room_id"] = a.RoomID
	a.fieldMap["room_ip"] = a.RoomIP
	a.fieldMap["card"] = a.Card
	a.fieldMap["cadr_id"] = a.CadrID
	a.fieldMap["table_date"] = a.TableDate
	a.fieldMap["room_name"] = a.RoomName
	a.fieldMap["card_type"] = a.CardType
}

func (a avtTimetableEx) clone(db *gorm.DB) avtTimetableEx {
	a.avtTimetableExDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a avtTimetableEx) replaceDB(db *gorm.DB) avtTimetableEx {
	a.avtTimetableExDo.ReplaceDB(db)
	return a
}

type avtTimetableExDo struct{ gen.DO }

type IAvtTimetableExDo interface {
	gen.SubQuery
	Debug() IAvtTimetableExDo
	WithContext(ctx context.Context) IAvtTimetableExDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IAvtTimetableExDo
	WriteDB() IAvtTimetableExDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IAvtTimetableExDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IAvtTimetableExDo
	Not(conds ...gen.Condition) IAvtTimetableExDo
	Or(conds ...gen.Condition) IAvtTimetableExDo
	Select(conds ...field.Expr) IAvtTimetableExDo
	Where(conds ...gen.Condition) IAvtTimetableExDo
	Order(conds ...field.Expr) IAvtTimetableExDo
	Distinct(cols ...field.Expr) IAvtTimetableExDo
	Omit(cols ...field.Expr) IAvtTimetableExDo
	Join(table schema.Tabler, on ...field.Expr) IAvtTimetableExDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IAvtTimetableExDo
	RightJoin(table schema.Tabler, on ...field.Expr) IAvtTimetableExDo
	Group(cols ...field.Expr) IAvtTimetableExDo
	Having(conds ...gen.Condition) IAvtTimetableExDo
	Limit(limit int) IAvtTimetableExDo
	Offset(offset int) IAvtTimetableExDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IAvtTimetableExDo
	Unscoped() IAvtTimetableExDo
	Create(values ...*model.AvtTimetableEx) error
	CreateInBatches(values []*model.AvtTimetableEx, batchSize int) error
	Save(values ...*model.AvtTimetableEx) error
	First() (*model.AvtTimetableEx, error)
	Take() (*model.AvtTimetableEx, error)
	Last() (*model.AvtTimetableEx, error)
	Find() ([]*model.AvtTimetableEx, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.AvtTimetableEx, err error)
	FindInBatches(result *[]*model.AvtTimetableEx, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.AvtTimetableEx) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IAvtTimetableExDo
	Assign(attrs ...field.AssignExpr) IAvtTimetableExDo
	Joins(fields ...field.RelationField) IAvtTimetableExDo
	Preload(fields ...field.RelationField) IAvtTimetableExDo
	FirstOrInit() (*model.AvtTimetableEx, error)
	FirstOrCreate() (*model.AvtTimetableEx, error)
	FindByPage(offset int, limit int) (result []*model.AvtTimetableEx, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IAvtTimetableExDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (a avtTimetableExDo) Debug() IAvtTimetableExDo {
	return a.withDO(a.DO.Debug())
}

func (a avtTimetableExDo) WithContext(ctx context.Context) IAvtTimetableExDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a avtTimetableExDo) ReadDB() IAvtTimetableExDo {
	return a.Clauses(dbresolver.Read)
}

func (a avtTimetableExDo) WriteDB() IAvtTimetableExDo {
	return a.Clauses(dbresolver.Write)
}

func (a avtTimetableExDo) Session(config *gorm.Session) IAvtTimetableExDo {
	return a.withDO(a.DO.Session(config))
}

func (a avtTimetableExDo) Clauses(conds ...clause.Expression) IAvtTimetableExDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a avtTimetableExDo) Returning(value interface{}, columns ...string) IAvtTimetableExDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a avtTimetableExDo) Not(conds ...gen.Condition) IAvtTimetableExDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a avtTimetableExDo) Or(conds ...gen.Condition) IAvtTimetableExDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a avtTimetableExDo) Select(conds ...field.Expr) IAvtTimetableExDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a avtTimetableExDo) Where(conds ...gen.Condition) IAvtTimetableExDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a avtTimetableExDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IAvtTimetableExDo {
	return a.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (a avtTimetableExDo) Order(conds ...field.Expr) IAvtTimetableExDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a avtTimetableExDo) Distinct(cols ...field.Expr) IAvtTimetableExDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a avtTimetableExDo) Omit(cols ...field.Expr) IAvtTimetableExDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a avtTimetableExDo) Join(table schema.Tabler, on ...field.Expr) IAvtTimetableExDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a avtTimetableExDo) LeftJoin(table schema.Tabler, on ...field.Expr) IAvtTimetableExDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a avtTimetableExDo) RightJoin(table schema.Tabler, on ...field.Expr) IAvtTimetableExDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a avtTimetableExDo) Group(cols ...field.Expr) IAvtTimetableExDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a avtTimetableExDo) Having(conds ...gen.Condition) IAvtTimetableExDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a avtTimetableExDo) Limit(limit int) IAvtTimetableExDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a avtTimetableExDo) Offset(offset int) IAvtTimetableExDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a avtTimetableExDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IAvtTimetableExDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a avtTimetableExDo) Unscoped() IAvtTimetableExDo {
	return a.withDO(a.DO.Unscoped())
}

func (a avtTimetableExDo) Create(values ...*model.AvtTimetableEx) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a avtTimetableExDo) CreateInBatches(values []*model.AvtTimetableEx, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a avtTimetableExDo) Save(values ...*model.AvtTimetableEx) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a avtTimetableExDo) First() (*model.AvtTimetableEx, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.AvtTimetableEx), nil
	}
}

func (a avtTimetableExDo) Take() (*model.AvtTimetableEx, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.AvtTimetableEx), nil
	}
}

func (a avtTimetableExDo) Last() (*model.AvtTimetableEx, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.AvtTimetableEx), nil
	}
}

func (a avtTimetableExDo) Find() ([]*model.AvtTimetableEx, error) {
	result, err := a.DO.Find()
	return result.([]*model.AvtTimetableEx), err
}

func (a avtTimetableExDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.AvtTimetableEx, err error) {
	buf := make([]*model.AvtTimetableEx, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a avtTimetableExDo) FindInBatches(result *[]*model.AvtTimetableEx, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a avtTimetableExDo) Attrs(attrs ...field.AssignExpr) IAvtTimetableExDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a avtTimetableExDo) Assign(attrs ...field.AssignExpr) IAvtTimetableExDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a avtTimetableExDo) Joins(fields ...field.RelationField) IAvtTimetableExDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a avtTimetableExDo) Preload(fields ...field.RelationField) IAvtTimetableExDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a avtTimetableExDo) FirstOrInit() (*model.AvtTimetableEx, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.AvtTimetableEx), nil
	}
}

func (a avtTimetableExDo) FirstOrCreate() (*model.AvtTimetableEx, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.AvtTimetableEx), nil
	}
}

func (a avtTimetableExDo) FindByPage(offset int, limit int) (result []*model.AvtTimetableEx, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a avtTimetableExDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a avtTimetableExDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a avtTimetableExDo) Delete(models ...*model.AvtTimetableEx) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *avtTimetableExDo) withDO(do gen.Dao) *avtTimetableExDo {
	a.DO = *do.(*gen.DO)
	return a
}
